---
title: "examine_3prime_breakpoint_readlengths"
author: "bhaas"
date: '2024-02-10'
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```


```{r}

files = list.files("../data/", "*read_lengths.tsv.gz")

data = NULL

for (file in files) {
    df = read.table(paste0("../data/", file), sep="\t", header=T, check.names = FALSE)
    df$sample = str_replace(file, ".3prime_brkpt_read_lengths.tsv", "")
    data = bind_rows(data, df)
}

data %>% head()
```

## Examine according to relative FFPM support

```{r}

data %>% ggplot(aes(y=`SR/LR`, x=threePrimeBrkLen)) + geom_point() +
    facet_wrap(~sample, scale='free') +
     stat_smooth(method = "lm", 
              formula = y ~ x, 
              geom = "smooth") 


```



```{r}

data %>% ggplot(aes(y=log10(`SR/LR`), x=threePrimeBrkLen)) + geom_point() +
    facet_wrap(~sample) +
     stat_smooth(method = "lm", 
              formula = y ~ x, 
              geom = "smooth")


```


# Examine according to reads per GB sequenced.

```{r}
library(data.table)
data_GB = fread("../DepMap_v1v2mrgd.ctatLRF_FI.consolidated.tsv.gz", header=T, sep="\t", stringsAsFactors = F, drop=c("LR_accessions", "JunctionReads", "SpanningFrags", "CounterFusionLeftReads", "CounterFusionRightReads")) %>% rename(FusionName = fusion)

```

```{r}

data_GB = right_join(
                    data_GB %>% group_by(FusionName, LeftLocalBreakpoint, RightLocalBreakpoint) %>% arrange(desc(SR_FFPGB)) %>% filter(row_number() == 1) %>% ungroup(),
                    
                     data %>% select(FusionName, RightLocalBreakpoint, threePrimeBrkLen, align_len), 
                    
                     by=c('FusionName', 'RightLocalBreakpoint') )

```


```{r}

data_GB = data_GB %>% mutate(`SR_GB/LR_GB` = SR_FFPGB/LR_FFPGB)

```



```{r}

data_GB %>% 
    mutate(threePrimeBrkLenAdj = ifelse(threePrimeBrkLen < 2000, 2000, threePrimeBrkLen)) %>%
    ggplot(aes(y=log10(`SR_GB/LR_GB`), x=threePrimeBrkLen)) + 
    theme_bw() +
    geom_point(aes(color=threePrimeBrkLenAdj)) +
    stat_smooth(method = "lm", 
              formula = y ~ x, 
              geom = "smooth") +
    geom_hline(yintercept=0) +
    ggtitle("short/long read support per GB sequenced ~ brkpt distance from 3' end of read")


```


```{r}


cor.test(data_GB$threePrimeBrkLen, log10(data_GB$`SR_GB/LR_GB`))


```


```{r}

brkpt_dist_findings_plot = data_GB %>% 
    mutate(threePrimeBrkLenAdj = ifelse(threePrimeBrkLen < 2000, 2000, threePrimeBrkLen)) %>%
    ggplot(aes(y=log10(`SR_GB/LR_GB`), x=threePrimeBrkLen)) + 
    theme_bw() +
    geom_point(aes(color=threePrimeBrkLenAdj)) +
    facet_wrap(~sample) +
     stat_smooth(method = "lm", 
              formula = y ~ x, 
              geom = "smooth") +
    geom_hline(yintercept=0) +
    ggtitle("short/long read support per GB sequenced ~ brkpt distance from 3' end of read")

brkpt_dist_findings_plot

```

```{r}

ggsave(brkpt_dist_findings_plot, file="SRenrich_vs_3primebrkptdist.svg", width=9, height=7)


```




```{r}

cell_lines = data_GB %>% select(sample) %>% unique() %>% pull(sample)

threeprimebrklen_summary_stats = NULL

for (cell_line in cell_lines) {
    #print(cell_line)
    cell_line_data = data_GB %>% filter(sample == cell_line)
    #print(cell_line_data)
    c = cor.test(cell_line_data$threePrimeBrkLen, log10(cell_line_data$`SR_GB/LR_GB`))
    #print(c)
    
    R = c$estimate
    p = c$p.value
    
    threeprimebrklen_summary_stats = bind_rows(threeprimebrklen_summary_stats, data.frame(sample=cell_line, R=R, p=p))
    
}

threeprimebrklen_summary_stats %>% arrange(p, R)


```




```{r}

data_GB = data_GB %>% group_by(sample) %>% arrange(desc(`SR_GB/LR_GB`)) %>% mutate(rn=row_number()) %>% ungroup() 
```

```{r}
SRenrich_vs_ranking_plot = data_GB %>%
    mutate(threePrimeBrkLenAdj = ifelse(threePrimeBrkLen < 2000, 2000, threePrimeBrkLen)) %>%
    ggplot() + theme_bw() +
    geom_point(aes(x=rn, y=log10(`SR_GB/LR_GB`), color=threePrimeBrkLenAdj)) +
    facet_wrap(~sample) +
    geom_hline(yintercept=0) +
    ggtitle("Fusions ranked by SR/LR support per GB sequenced")

SRenrich_vs_ranking_plot
```


```{r}

ggsave(SRenrich_vs_ranking_plot, file="SRenrich_vs_ranking.svg", width=9, height=7)

```



```{r}

data_GB %>%
    filter(rn <= 5) %>%
    arrange(sample, rn) %>%
    select(sample, FusionName, threePrimeBrkLen, `SR_GB/LR_GB`)

   
# 106-fold difference in BCR::ABL1 detection from SR vs. LR based on GB sequenced.

```


```{r}
# examine correlations

data_GB_min2k = data_GB %>% filter(threePrimeBrkLen >= 2000)

cor.test(data_GB_min2k$`SR_GB/LR_GB`, data_GB_min2k$threePrimeBrkLen)

# cor = 0.21, p = 0.1 (for min 2k from breakpoint)


```

# K562 example

```{r}

K562_brkpt_dist_findings_plot = data_GB %>% 
    filter(sample == "K562") %>%
    mutate(threePrimeBrkLenAdj = ifelse(threePrimeBrkLen < 2000, 2000, threePrimeBrkLen)) %>%
    ggplot(aes(y=log10(`SR_GB/LR_GB`), x=threePrimeBrkLen)) + 
    theme_bw() +
    geom_point(aes(color=threePrimeBrkLenAdj)) +
    geom_hline(yintercept=0) +
    ggtitle("K562 short/long read support per GB sequenced ~ brkpt distance from 3' end of read")


K562_brkpt_dist_findings_plot


```

```{r}

ggsave(K562_brkpt_dist_findings_plot, file="K562_SRenrich_vs_3primebrkptdist.svg", width=6, height=4)


```



```{r}

K562_SRenrich_vs_ranking_plot = data_GB %>%
    filter(sample=="K562") %>%
    mutate(threePrimeBrkLenAdj = ifelse(threePrimeBrkLen < 2000, 2000, threePrimeBrkLen)) %>%
    ggplot() + theme_bw() +
    geom_point(aes(x=rn, y=log10(`SR_GB/LR_GB`), color=threePrimeBrkLenAdj)) +
    geom_hline(yintercept=0) +
    ggtitle("K562 Fusions ranked by SR/LR support per GB sequenced")

K562_SRenrich_vs_ranking_plot

```

```{r}

ggsave(K562_SRenrich_vs_ranking_plot, file="K562_SRenrich_vs_ranking.svg", width=6, height=4)


```

# Examine SR enrichment ~ fusion transcript length


```{r}


data_GB %>% ggplot(aes(x=align_len, y=log10(`SR_GB/LR_GB`))) + geom_point() +
    theme_bw() +
    stat_smooth(method = "lm", 
              formula = y ~ x, 
              geom = "smooth") +
      geom_hline(yintercept=0) +
    ggtitle("SR/LR ~ alignment length")


```


```{r}


cor.test(data_GB$align_len, log10(data_GB$`SR_GB/LR_GB`))


```



```{r}


data_GB %>% ggplot(aes(x=align_len, y=log10(`SR_GB/LR_GB`))) + geom_point() +
    theme_bw() +
    stat_smooth(method = "lm", 
              formula = y ~ x, 
              geom = "smooth") +
    facet_wrap(~sample) +
    ggtitle("SR/LR ~ alignment length per cell line")


```


```{r}

cell_lines = data_GB %>% select(sample) %>% unique() %>% pull(sample)

summary_stats = NULL

for (cell_line in cell_lines) {
    #print(cell_line)
    cell_line_data = data_GB %>% filter(sample == cell_line)
    #print(cell_line_data)
    c = cor.test(cell_line_data$align_len, log10(cell_line_data$`SR_GB/LR_GB`))
    #print(c)
    
    R = c$estimate
    p = c$p.value
    
    summary_stats = bind_rows(summary_stats, data.frame(sample=cell_line, R=R, p=p))
    
}

summary_stats %>% arrange(p, R)


```


# we find the most distal breakpoints with the longest fusion RNAs

```{r}

data_GB %>% ggplot(aes(x=align_len, y=threePrimeBrkLen)) + geom_point()



```
```{r}

cor.test(data_GB$threePrimeBrkLen, data_GB$align_len)


```

ie. if the breakpoint is far away from the 3' end, we'll obviously only capture it with the longest of fusion reads sequenced.



